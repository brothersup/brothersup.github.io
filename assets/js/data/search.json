[ { "title": "3. jenkins를 활용해서 spring boot 프로젝트 빌드하기", "url": "/posts/5/", "categories": "study, CI/CD", "tags": "DevOps, jenkins, 젠킨스, CI/CD, gradle", "date": "2022-12-12 02:11:00 +0900", "snippet": "jenkins를 활용해서 spring boot 프로젝트 빌드하기이번 포스팅에서는 깃허브 저장소에서 내려받은 스프링 부트 프로젝트를 gradle로 빌드해볼 예정입니다.지난번 생성한 저장소에 엄청 간단한 기능(http://localhost:8080 로 접속하면 화면에 hello를 띄우는 코드)뿐인프로젝트를 push했고 이 부분은 포스팅하려는 내용과는 별 상관없어 보여서 생략했습니다.그리고 그냥 혼자 정리하는 노트 느낌으로 반말로 작성했었으나 이번 포스팅부터는 높임말을 사용해서 작성하도록 하겠습니다 ㅎㅎ1. jenkins gradle 플러그인 설치Jenkins 관리 &amp;gt; 플러그인 관리 페이지에 들어가서 Gradle Plugin을 설치합니다. 제 젠킨스 서버는 이미 설치가 되어있었습니다.다음으로는 Eclipse Temurin installer를 설치합니다.(이후 툴 설정에서 open jdk를 다운받기 위함인데 별도의 설치파일이나 링크를 사용하실 분들이나jdk 11 이후 버전이 필요가 없으신 분들은 설치하지 않으셔도 됩니다.)2. jenkins global tool configuration다음은 Jenkins 관리 &amp;gt; Global Tool Configuration 페이지에 들어갑니다.우선 jdk 17 설치를 위한 설정을 해줍니다. 앞단계에서 Eclipse Temurin installer를 설치하셨다면 add installer에 install from adoptium.net 메뉴가 추가되는데,이를 선택한 다음 버전을 선택해줍니다. Name은 이후 파이프라인 스크립트에서 사용될 예정이니 적당한 이름을 입력합니다.(마찬가지로 jdk 11 이후 버전이 필요 없으신 분들은 gradle 설정만 하시면 됩니다.)다음은 Gradle 관련 화면이 보이는데 jdk와 마찬가지로 적당한 이름을 입력하고 버전을 선택해줍니다. 설정이 완료되면 Save 버튼을 클릭해서 저장해줍니다. 어느 버전을 선택해야할지 모르겠다면 프로젝트 내에 gradle/wrapper/gradle-wrapper.properties 파일을 열어서 버전을 확인하시면 됩니다.3. Jenkins Pipeline script 내용 추가다음은 지난 포스팅에서 생성했던 아이템의 구성 페이지에 접속해서 기존에 작성했던 스크립트에 tools와 stage(‘build’) 부분을 추가합니다.(&amp;lt;&amp;gt;안의 내용은 각자 설정에 맞게 입력합니다. 앞 단계에서 jdk관련 설정을 생략하셨다면 tools의 jdk는 생략합니다.)pipeline { agent any tools { jdk &#39;&amp;lt;jdk name&amp;gt;&#39; gradle &#39;&amp;lt;gradle name&amp;gt;&#39; } stages { stage(&#39;git clone&#39;) { steps { git branch: &#39;&amp;lt;branch name&amp;gt;&#39;, credentialsId: &#39;&amp;lt;credietial id&amp;gt;&#39;, url: &#39;&amp;lt;github repository url&amp;gt;&#39; } } stage(&#39;build&#39;) { steps { sh &#39;./gradlew clean build&#39; } } }}3. 빌드 확인젠킨스의 아이템 메뉴에서 지금 빌드를 클릭하면 tools 설치과정이 선행되는데 처음 설치시에는 시간이 좀 걸리지만 다음부터는 금방 넘어갑니다.설치단계가 끝나면 스크립트로 작성한 두 개의 스테이지를 차례로 진행하게 되고 별 문제가 없으면 초록불이 뜨면서 빌드에 성공합니다.4. 정리이번 포스팅에서는 젠킨스에 jdk와 gradle을 추가하고 약간의 pipeline script 수정을 통해 코드를 내려받아 빌드까지 진행했습니다.원래 배포까지 작성할 예정이었으나 빌드결과를 보듯이 빌드 실패도 여러번나서 포스팅 수정도 몇번하고 jdk 버전 이슈때문에 jdk 버전 추가까지 넣느라거의 다시쓰는 정도로 수정을 많이해서 여기까지만 포스팅하고 배포는 다음 포스팅에서는 정리하면서 마무리 할 예정입니다." }, { "title": "2. github-jenkins 연동", "url": "/posts/4/", "categories": "study, CI/CD", "tags": "DevOps, jenkins, 젠킨스, CI/CD", "date": "2022-12-11 03:45:00 +0900", "snippet": "깃허브와 젠킨스 연동지난 포스팅에서 도커를 설치하고 도커를 사용해서 젠킨스 서버를 띄웠다.(지난포스팅 참고)이번에는 젠킨스와 깃허브를 연동할 예정이다.1. 권한 설정1-1. 깃허브 토큰 발급오른쪽 위에 있는 프로파일 이미지를 클릭하면 메뉴가 나오는데 여기서 Settings를 클릭한다.왼쪽 메뉴 중 Developer settings 에 들어간 다음 Personal access tokens &amp;gt; Tokens (classic) 메뉴를 선택한다.Generate new token (classic) 을 클릭해서 토큰을 생성하는 페이지로 들어간다.Note를 입력하고 Expiration을 선택한 다음 Select scopes 에서 repo, admin:repo_hook를 선택한다.노트는 그냥 어디에 사용되는 토큰인지 식별만 가능하게 아무렇게나 지어도 무관하다.Generate token 버튼을 클릭하면 토큰이 생성된다.1-2. 젠킨스 credential 추가젠킨스 인덱스 페이지에서 Jenkins 관리 &amp;gt; Manage Credentials 페이지에서 System 옆에 있는(global)에 마우스를 올려두면 화살표가 생기는데 클릭한 다음 Add credentials를 클릭한다Username에 깃허브 사용자명을 입력하고 Password에는 앞서 생성한 토큰을 입력한다.ID는 빈칸으로 두면 자동으로 생성되기 때문에 생략하고 create 버튼을 클릭하면 권한 설정은 끝난다.2. 젠킨스 파이프라인 생성젠킨스 인덱스 페이지의 왼쪽 메뉴에서 새로운 Item 을 선택해서 아이템을 추가하는 페이지로 이동한다.추가 페이지에서 아이템 이름을 입력하고 Pipeline을 선택한 다음 OK 버튼을 클릭한다.Build Triggers에 Github hook trigger for GITScm polling 을 체크한다.다음은 pipeline script에 다음과 같이 입력한다. branch, credentialsId, url은 상황에 맞게 수정해준다.pipeline { agent any stages { stage(&#39;git clone&#39;) { steps { git branch: &#39;브랜치 이름&#39;, credentialsId: &#39;젠킨스 credential의 id&#39;, url: &#39;github repository url&#39; } } }}branch는 해당 브랜치에 push 이벤트가 발생하면 해당 브랜치의 이벤트를 캐치하도록 설정할 브랜치명을 적는 부분이고,credentialsId는 앞서 생성한 젠킨스 credential의 id를 적어준다.(이 포스팅 기준 앞서 자동생성되도록 빈칸으로 둬서 자동생성된 id)그리고 마지막으로 url은 깃허브 저장소의 주소를 적어준다.해당 스크립트의 내용은 깃허브 저장소의 웹훅 설정에서 지정한 이벤트(다음 단계에서 설정할 예정)가 발생하면 저장소의 코드를 젠킨스 서버에 코드를 내려받는 내용이다.이 부분은 이후 포스팅을 통해 내려받은 코드를 빌드하고 배포하도록 스크립트를 추가해줄 예정이다.저장 버튼을 클릭하고 빠져나오면 우선 파이프라인 설정은 끝이다.3. 깃허브 저장소 설정깃허브 저장소의 설정페이지에서 Webhooks 메뉴를 선택한 다음 Add webhook 버튼을 클릭한다.Payload URL을 입력하고 Content Type은 application/json으로 선택해준다.페이로드 url의 경우 젠킨스 서버의 주소 뒤에 /github-webhook/을 추가한 문장으로 입력하고젠킨스 서버의 주소는 localhost나 ip가 아닌 외부에서 접속 가능한 주소를 사용해서 입력해준다. 페이로드 url의 경우 마지막에 /를 붙여주지 않으면 젠킨스 서버에 요청을 실패하니 붙여주도록 한다.입력이 끝나면 Add webhook 버튼을 클릭해서 저장한다.웹훅 추가를 마치고 나온 화면(바로 위 이미지 화면)에서 Edit 버튼을 클릭한 다음 Recent Deliveries 탭을 선택하면 핑 테스트 결과가 나온다.초록색 체크가 떠있으면 github 저장소의 webhook 설정이 끝난다.4. 테스트제대로 동작하는지 확인하기 위해 리드미 파일을 수정하고 푸쉬해보았다.성공!!정리깃허브와 젠킨스 연동까지 끝났다. 원래 깃랩으로 했던거라 깃허브로 새로 해봤지만 플러그인이 필요없어서 조금더 간단했다.다음은 젠킨스 파이프라인 스크립트를 수정해서 코드를 받은다음 빌드까지 되도록 만들고 스프링부트로 테스트용 프로젝트를 하나 만든 다음 푸쉬를 해서 확인하는 내용까지 포스팅 할 예정이다." }, { "title": "1. Jenkins 설치", "url": "/posts/3/", "categories": "study, CI/CD", "tags": "DevOps, docker, jenkins, 도커, 젠킨스, CI/CD", "date": "2022-11-27 16:43:00 +0900", "snippet": "최근에 회사에서 젠킨스와 깃랩 저장소를 연동해서 특정 브랜치에 push나 merge 이벤트가 발생하면 빌드를 하고원격서버에 배포하는 파이프라인을 만들었는데 만든김에 기억날때 정리하려고 한다. 예전에 aws code deploy와bitbucket의 저장소를 연동해서 푸쉬하면 인스턴스에 자동으로 빌드하고 배포하도록 했었는데 그때와 비슷한 것 같았다.회사에서는 깃랩을 사용했지만 포스팅은 깃허브를 사용할 예정이고 포스팅이 길어질 것 같아서 나눠서 쓸 예정이다.이번 포스팅에서는 도커를 사용해서 젠킨스를 설치하고 기본설정까지 기록할 예정이다.깃허브의 저장소와 젠킨스를 연동 &amp;gt; 저장소의 특정 브랜치에 이벤트가 발생하면 저장소로부터 코드를 내려받음 &amp;gt;빌드를 하고 생성된 결과물을 원격으로 전송하고 실행순으로 기록할 예정인데 내키는대로 포스팅하다보면 빠지거나 바뀔 수도 있다.개요도커는 응용프로그램들을 프로세스 격리 기술들을 사용해 컨테이너로 실행하고 관리하는 오픈소스 프로젝트이고,젠킨스는 CI/CD 환경을 구축하기위한 도구이다. 도커 컨테이너에 젠킨스 서버를 띄우고 로컬환경에 접속하면포트포워딩을 통해 젠킨스 서버에 접근한다.Docker 설치homebrew를 통해 cask를 설치하고 homebrew와 cask를 사용해서 도커를 설치해준다.명령어를 통해 설치할 수도 있고, 공식홈페이지에서도 설치파일을 받아 설치 가능하다.brew install caskbrew install --cask dockerJenkins 설치도커 허브의 공식 이미지에서 젠킨스를 찾아보면 다음과 같이 쓰여있다.따라서 터미널에서 다음을 입력해서 젠킨스 이미지를 받아준다.docker pull jenkins/jenkins:lts명령어를 실행시킨 다음 도커 데스크탑의 왼쪽 메뉴에 images를 클릭해보면 젠킨스 이미지가 추가되어있다. 캡쳐한 시점에선 이미 컨테이너를 실행시킨 상태라 status가 in use로 떠있으니 참고.다음은 이미지 목록에서 Actions에 있는 Run 버튼을 클릭한다. 버튼을 클릭하면 세팅할 수 있는 창이 나타나는데 Ports와 Volumes를 입력해준다. 여기서 Ports를 10001번으로 지정해주었는데 별 의미는 없다. http://localhost:10001 으로 접속하면 컨테이너의 8080포트로 포트포워딩되어 젠킨스 서버에 접속된다. Volumes는 컨테이너에서 젠킨스가 설치된 경로(container path)로 지정해준 내 노트북의 경로가 사용되어 젠킨스에서 생성되고 사용되는 데이터가 내 노트북에도 남게된다. 실행시킨 다음 컨테이너 목록에서 포트번호를 클릭하거나 http://localhost:10001을 입력하면 젠킨스 첫 화면이 나타난다.여기서 비밀번호를 입력해야하는데 컨테이너의 로그를 보면 초기 비밀번호를 확인할 수 있다.또는 컨테이너를 실행시킬 때 설정한 젠킨스 홈 경로하위에 secrets/initialAdminPassword 파일을 열어도 비밀번호를 확인할 수 있다.비밀번호를 입력해주고 다음 단계로 넘어간다.다음은 플러그인 관련 화면인데 젠킨스는 처음이라 일단 왼쪽을 선택해주었다.플러그인 설치가 끝나면 관리자 계정을 설정하는 화면이 나타난다.입력하고 다음으로 넘어가면 jenkins url 설정하는 화면이 나오는데 일단 넘어간다.넘어가고 start using jenkins 버튼을 클릭하면 젠킨스 인덱스 페이지가 나오고 설치와 기본 설정이 끝난다.정리젠킨스와 도커 모두 처음 설치해봤지만 별로 어려운점은 없었다. 다음 포스팅때는 깃허브와 연동에 필요한 젠킨스 플러그인을 설치하고 깃허브에 저장소를 생성해서 연동까지 정리할 예정이다." }, { "title": "마크다운 문법 - Table", "url": "/posts/2/", "categories": "study, markdown", "tags": "마크다운, markdown", "date": "2022-03-06 03:59:00 +0900", "snippet": "자주써서 익숙한 문법들 말고 가끔써서 익숙하지 않아서 자꾸 찾아보게 되는 것들 위주로 정리할 예정이다.일단 이번 포스팅에선 테이블에 대해 정리했다. 부족한 내용은 나중에 새로 알게되는대로 추가하도록 하겠다.Table기본문법 파이프(|)와 하이픈(-)을 사용해서 테이블을 만들 수 있다. 파이프는 열을 구분할 때 사용되고, 하이픈은 컬럼의 헤더를 구분할 때 사용된다(하이픈은 세개나 그 이상 붙여서 사용). 셀 너비는 굳이 맞춰서 작성하지 않아도 출력시 동일하게 표현된다. 특수문자를 표현할 때 HTML 문자코드를 사용할 수 있다.(테이블뿐 아니라 일반 구문에서도 가능)ex) | -&amp;gt; &amp;amp;#124; 문법| 포지션 | ID || ----- | -------- || 탑 | Zeus || 정글 | Oner || 미드 | Faker || 원딜 | Gumayusi || 서폿 | Keria |출력 포지션 ID 탑 Zeus 정글 Oner 미드 Faker 원딜 Gumayusi 서폿 Keria Tip: 직접 만들기 귀찮다면 마크다운 테이블 생성기로 만들 수도 있다.gui를 사용해서 테이블을 만들고 markdown 형식의 텍스트를 복사하면된다.정렬 헤더를 구분하는 행에서 왼쪽이나 오른쪽, 양쪽에 콜론(:)을 붙여서 정렬을 할 수 있다.문법| 왼쪽 정렬 | 가운데 정렬 | 오른쪽 정렬 || :--- | :----: | ---: || text | text | text || text | text | text |출력 왼쪽 정렬 가운데 정렬 오른쪽 정렬 text text text text text text 테이블에서의 글꼴 서식 테이블의 셀 내에서 링크나 코드(코드블럭이 아닌 (`)로 감싸진 단어나 문장), 강조와 같은 글꼴 서식을 기존의 문법으로 추가할 수 있다. 제목(#), 코드블럭(```), 목록(-), 이미지(![])나 대부분의 HTML 태그등은 사용할 수 없다. 줄바꿈(br)이나 목록(ul, li)과 같은 표시를 HTML 문법을 사용해서 나타낼 수 있다.목록문법| Syntax | Description || ----------- | ----------- || Header | Title || List | Here&#39;s a list! &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;Item one.&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;Item two.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt; |출력 Syntax Description Header Title List Here’s a list! &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;Item one.&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;Item two.&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt; 원래 되는데 테마때문인지 여기에선 표시가 안된다;;줄바꿈문법| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | First paragragh. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt; Second paragraph. |출력 Syntax Description Header Title Paragraph First paragragh. Second paragraph. 참고 https://www.markdownguide.org/extended-syntax/#tables" }, { "title": "자바 입출력 - Scanner, BufferedReader, BufferedWriter", "url": "/posts/1/", "categories": "study, java", "tags": "java, 입출력, Scanner, bufferedReader, bufferedWriter", "date": "2022-03-05 17:53:00 +0900", "snippet": "최근 알고리즘공부를 시작하면서 몰랐거나 안써본 클래스들에 대해 많이 알게되었는데 그중에 하나가 콘솔로 입력값을 받는것이었다.예전에 학교에서 C언어를 배울때 scanf 함수를 써서 입력값을 받았던게 생각나서 검색해보니 자바에도 Scanner라는 클래스가 있어서 Scanner로 입력을 받다가, BufferedReader 클래스로도 입력을 받을 수 있다는 것을 알게되었다.성능이 더 좋다고 해서 그 뒤로는 BufferedReader를 사용해서 입력값을 받고있는데, BufferedWriter도 세트처럼 쓰는 것 같아서 출력시 함께 사용중이다. 그래서 쓰고있는 김에 복습도 할겸 정리해두려고 한다.Scanner java.util 패키지에 있는 클래스 입력받은 값을 문자나 정수, 실수, 문자열 등 다양한 타입으로 리턴해준다. 스페이스바나 엔터로 입력받은 값을 구분해서 나눠준다.사용 예import java.util.Scanner;public class ScannerTest { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String str = scanner.next(); int number = scanner.nextInt(); System.out.println(str); System.out.println(number); }} next(), nextInt() 메서드를 사용해서 각각 입력받은 값을 데이터타입에 맞게 받아서 출력하는 코드다. 값을 받는 메서드 개수만큼 입력을 받고 스페이스바나 엔터 입력으로 구분한다. 구분은 스페이스, 엔터 모두 가능 데이터 타입이 다르면 예외가 발생하므로 주의!!BufferedReader / BufferedWriter java.io 패키지에 있는 클래스 사용이 끝나면 close() 메서드를 호출하도록 한다. 메서드를 사용하기위해서 예외처리가 필요하다.BufferedReader readLine() 메서드를 사용해서 입력값을 받음. 줄단위로 입력을 받기 때문에 구분은 Scanner 클래스와 달리 엔터로만 구분된다. Scanner 처럼 스페이스바로 구분하려면 split() 같은 메서드를 사용하면 된다. 입력받은 값은 String 타입으로 반환하기 때문에 별도의 캐스팅이 필요하다. Scanner에 비해 훨씬 큰 버퍼의 크기를 갖고있다. Scanner는 입력 데이터를 파싱하지만 BufferedReader는 파싱 과정이 없기때문에 Scanner보다 속도가 빠르다.BufferedWriter 버퍼에 저장된 데이터를 flush()나 close() 메서드가 호출될 때 출력스트림으로 내보낸다. 개행문자가 포함되지 않기때문에 줄바꿈을 하려면 입력끝에 개행문자를 넣어주거나 newLine() 메서드를 사용한다. 정수형을 출력할 경우 파라미터로 받은 정수를 문자의 코드값으로 인식해서 해당 문자를 출력하므로 String.valueOf() 메서드로 문자로 바꾼다음 출력해야 한다.println()과 write() 특징 비교import java.io.*;public class BufferedIOTest { public static void main(String[] args) { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); try { // 입력받은 문자열을 그대로 출력 String str1 = br.readLine(); System.out.println(&quot;println = &quot; + str1); bw.write(&quot;write = &quot; + str1); bw.newLine(); // 줄바꿈 처리 // 입력받은 문자열을 공백으로 구분 String[] str2 = br.readLine().split(&quot; &quot;); for (String s : str2) { System.out.println(&quot;println = &quot; + s); bw.write(&quot;write = &quot; + s); bw.newLine(); } // 입력받은 숫자들의 합 String[] numbers = br.readLine().split(&quot; &quot;); int total = 0; for (String number : numbers) { total += Integer.parseInt(number); } System.out.println(&quot;println = &quot; + total); bw.write(&quot;write = &quot; + total); // bufferedReader 사용 끝 br.close(); bw.close(); // close메서드가 호출되면 flush가 먼저 일어난 다음 close된다. } catch (IOException e) { e.printStackTrace(); } }}출력 결과 write() 다음줄에 newLine() 메서드를 호출해서 개행처리를 하고있음을 볼 수 있다. 결과를 보면 알수있듯이 println()은 호출되자마자 출력하지만 write()는 모아뒀다가 한번에 출력한다. 정수형 출력 예import java.io.*;public class IntegerPrintTest { public static void main(String[] args) { BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); try { bw.write(97); // 출력값: a bw.newLine(); bw.write(String.valueOf(97)); // 출력값: 97 bw.close(); } catch (IOException e) { e.printStackTrace(); } }}마무리첫 포스팅으로 입출력 관련 클래스들의 특징과 각 클래스들에서 자주쓰는 메소드에 대해 간단히 알아보았다.Scanner는 입력값을 편하게 받을 수 있다는 장점과 파싱하고 캐스팅하느라 처리속도가 BufferedReader에 비해 느리다는 단점이 있다.BufferedReader는 속도는 빠르지만 예외처리, 파싱, 캐스팅하느라 번거롭기 때문에 다수의 캐스팅이 필요하거나 입력값이 적을 땐 그냥 Scanner를 쓰고 그 외엔 BufferedReader/Writer를 사용하면 될 것 같다.(개인적인 생각..)정리한 내용 외에도 입출력에 관련된 많은 클래스들과 메소드들이 있지만, 아직은 쓰는일이 없기 때문에 나중에 쓰게되면 알아봐야겠다.참고 자바11 api 문서 - Scanner, BufferedReader, BufferedWriter https://www.geeksforgeeks.org/difference-between-scanner-and-bufferreader-class-in-java/ https://www.quora.com/Why-is-Scanner-so-much-slower-than-BufferedReader" } ]
